package com.example.driver.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.example.driver.Entity.Driver;
import com.example.driver.Entity.DriverRideRequest;
import com.example.driver.Entity.ORSRouteResponse;
import com.example.driver.ORSClient.OpenRouteServiceClient;
import com.example.driver.Repository.DriverRepository;
import com.example.driver.client.RideServiceClient;


@Service
public class DriverService {

    @Autowired
    private DriverRepository driverRepository;
    
    private ScheduledExecutorService scheduler;

    private List<List<Double>> activeRoute = new ArrayList<>();
    private int routePointer = 0;

    private Long currentDriverId = null;     // track which driver is running
    private boolean routeCompleted = false;

    @Autowired
    private RideServiceClient rideClient;

    @Autowired
    private OpenRouteServiceClient orsClient;

    @Value("${ors.api.key}")
    private String apiKey;


    public void setActiveRoute(List<List<Double>> route) {
        this.activeRoute = route;
        this.routePointer = 0;
        this.routeCompleted = false;
    }


    // ------------------------------
    //  SIMULATION LOGIC FIXED HERE
    // ------------------------------
    public void simulateMovement() {

        if (currentDriverId == null) return;

        if (activeRoute == null || routePointer >= activeRoute.size()) {

            if (!routeCompleted) {
                System.out.println("Route completed — stopping movement updates.");
                routeCompleted = true;
            }

            stopMovement();   // STOP SCHEDULER CLEANLY
            return;
        }

        List<Double> point = activeRoute.get(routePointer);
        double lon = point.get(0);
        double lat = point.get(1);

        routePointer++;

        System.out.println("Driver Id: " + currentDriverId);

        updateLocation(currentDriverId, lat, lon);
    }


    // ------------------------------
    //  START + STOP MOVEMENT
    // ------------------------------
    public void startMovement(Long driverId) {

        stopMovement(); // always stop old scheduler first

        this.currentDriverId = driverId;

        scheduler = Executors.newSingleThreadScheduledExecutor();

        scheduler.scheduleAtFixedRate(() -> simulateMovement(),
                0, 15, TimeUnit.SECONDS);
    }


    public void stopMovement() {
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdownNow();
        }
        scheduler = null;
    }



    // ------------------------------
    // PREPARE ROUTE & START MOVING
    // ------------------------------
    public void prepareRouteAndStart(DriverRideRequest req) {

        Long driverId = req.getDriverId();

        List<List<Double>> route = fetchRoute(
                req.getPickupLat(),
                req.getPickupLon(),
                req.getDropLat(),
                req.getDropLon()
        );

        setActiveRoute(route);

        startMovement(driverId);
    }


    // ------------------------------
    // UPDATE LOCATION
    // ------------------------------
    public Driver updateLocation(Long driverId, Double latitude, Double longitude) {
        Driver driver = driverRepository.findById(driverId)
                .orElseThrow(() -> new RuntimeException("Driver not found"));

        driver.setLatitude(latitude);
        driver.setLongitude(longitude);
        driverRepository.save(driver);

        rideClient.sendLocation(driverId, latitude, longitude);

        return driver;
    }
    
    public List<List<Double>> fetchRoute(Double startLat, Double startLon, Double endLat, Double endLon) {
        String start = startLon + "," + startLat;   // ORS uses lon,lat
        String end = endLon + "," + endLat;

        
        ORSRouteResponse response = orsClient.getRoute(apiKey, start, end);
//        String raw = orsClient.getRoute(apiKey, start, end);
        System.out.println("Raw response: "+response);
        
        if (response == null 
                || response.getFeatures() == null 
                || response.getFeatures().isEmpty()
                || response.getFeatures().get(0).getGeometry() == null) 
            {
                throw new RuntimeException("Invalid ORS response: Missing features/geometry");
            }

            return response.getFeatures().get(0).getGeometry().getCoordinates();
//        return response.getRoutes().get(0).getGeometry().getCoordinates();
    }
}


//@Service
//public class DriverService {
//
//    @Autowired
//    private DriverRepository driverRepository;
//    
//    private List<List<Double>> activeRoute = new ArrayList<>();
//    private int routePointer = 0;
//    
//    @Autowired
//    private RideServiceClient rideClient;
//    
//    @Autowired
//    private OpenRouteServiceClient orsClient;
//    
//    private boolean routeCompleted = false;
//
//
//    @Value("${ors.api.key}")
//    private String apiKey;
//
//
//    public Driver register(Driver driver) {
//        return driverRepository.save(driver);
//    }
//
//    public void setActiveRoute(List<List<Double>> route) {
//        this.activeRoute = route;
//        this.routePointer = 0; // reset movement
//    }
//    
//    public List<Driver> getAllDrivers() {
//        return driverRepository.findAll();
//    }
//    

//    
//    public void simulateMovement(Long driverId) {
//        if (activeRoute == null || routePointer >= activeRoute.size()) {
//        	if(!routeCompleted) {
//            System.out.println("Route completed — stopping movement updates.");
//            routeCompleted= true;}
//        	
//            return;
//        }
//
//        routeCompleted = false;
//        if (routePointer < activeRoute.size()) {
//
//            List<Double> point = activeRoute.get(routePointer);
//            double lon = point.get(0);
//            double lat = point.get(1);
//
//            routePointer++;
//System.out.println("Driver Id: "+driverId);
//            updateLocation(driverId, lat, lon);  // calling your existing method
//        }
//    }
//    
//    public void prepareRouteAndStart(DriverRideRequest req) {
//        Long driverId = req.getDriverId();
//        double pickupLat = req.getPickupLat();
//        double pickupLon = req.getPickupLon();
//        double dropLat = req.getDropLat();
//        double dropLon = req.getDropLon();
//System.out.println("Inside prepare Route start method");
//        // 1️⃣ Fetch route from ORS
//        List<List<Double>> route = fetchRoute(
//            pickupLat,
//            pickupLon,
//            dropLat,
//            dropLon
//        );
//        System.out.println("Fetch Route Worked");
//
//        // 2️⃣ Store in active route
//        setActiveRoute(route);
//
//        // 3️⃣ Start simulation immediately
//        simulateMovement(driverId);
//    }
//
//    public Driver updateLocation(Long driverId, Double latitude, Double longitude) {
//        Driver driver = driverRepository.findById(driverId)
//                .orElseThrow(() -> new RuntimeException("Driver not found"));
//        driver.setLatitude(latitude);
//        driver.setLongitude(longitude);
//        Driver updated = driverRepository.save(driver);
//
//        // NEW — Notify Ride Service
//        rideClient.sendLocation(driverId, latitude,longitude);
//
//        return updated;
//    }
//}

