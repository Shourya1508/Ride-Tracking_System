package com.example.driver.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.example.driver.Entity.Driver;
import com.example.driver.Entity.DriverRideRequest;
import com.example.driver.Entity.DriverTracker;
import com.example.driver.Entity.ORSRouteResponse;
import com.example.driver.ORSClient.OpenRouteServiceClient;
import com.example.driver.Repository.DriverRepository;
import com.example.driver.client.RideServiceClient;


@Service
public class DriverService {

    @Autowired
    private DriverRepository driverRepository;
    
    private ScheduledExecutorService scheduler;

    private List<List<Double>> activeRoute = new ArrayList<>();
    private int routePointer = 0;

    private Long currentDriverId = null;     // track which driver is running
    private boolean routeCompleted = false;

    @Autowired
    private RideServiceClient rideClient;

    @Autowired
    private OpenRouteServiceClient orsClient;

    @Value("${ors.api.key}")
    private String apiKey;

    private Map<Long, DriverTracker> driverTrackers = new ConcurrentHashMap<>();
    
    public Driver register(Driver driver) {
        return driverRepository.save(driver);
    }

    public List<Driver> getAllDrivers() {
        return driverRepository.findAll();
    }
   
    public List<List<Double>> fetchRoute(Double startLat, Double startLon, Double endLat, Double endLon) {

        String start = startLon + "," + startLat; 
        String end = endLon + "," + endLat;

        ORSRouteResponse response = orsClient.getRoute(apiKey, start, end);
        System.out.println("Raw response: " + response);

        if (response == null
                || response.getFeatures() == null
                || response.getFeatures().isEmpty()
                || response.getFeatures().get(0).getGeometry() == null) {

            throw new RuntimeException("Invalid ORS response: Missing features/geometry");
        }

        return response.getFeatures().get(0).getGeometry().getCoordinates();
    }


    // ----------------- PER DRIVER SIMULATION -------------------
    public void simulate(Long driverId) {

        DriverTracker tracker = driverTrackers.get(driverId);
        if (tracker == null) return;

        List<List<Double>> route = tracker.getRoute();

        if (tracker.getPointer() >= route.size()) {
            System.out.println("Driver " + driverId + " route completed. Stopping scheduler.");
            tracker.getScheduler().shutdown();
            driverTrackers.remove(driverId);
            return;
        }

        List<Double> point = route.get(tracker.getPointer());
        tracker.incrementPointer();

        double lon = point.get(0);
        double lat = point.get(1);

        updateLocation(driverId, lat, lon);
    }


    // ----------------- NEW RIDE REQUEST -------------------
    public void prepareRouteAndStart(DriverRideRequest req) {

        Long driverId = req.getDriverId();

        System.out.println("Preparing route for driver: " + driverId);

        List<List<Double>> route = fetchRoute(
                req.getPickupLat(),
                req.getPickupLon(),
                req.getDropLat(),
                req.getDropLon()
        );

        System.out.println("Route fetched successfully for driver: " + driverId);


        // if driver tracking already exists → stop old scheduler
        if (driverTrackers.containsKey(driverId)) {
            driverTrackers.get(driverId).getScheduler().shutdown();
            driverTrackers.remove(driverId);
        }

        // Create new tracker
        DriverTracker tracker = new DriverTracker();
        tracker.setRoute(route);
        tracker.setScheduler(Executors.newSingleThreadScheduledExecutor());

        driverTrackers.put(driverId, tracker);

        // Start movement every 15 seconds
        tracker.getScheduler().scheduleAtFixedRate(
                () -> simulate(driverId),
                0,
                15,
                TimeUnit.SECONDS
        );
    }


    // ----------------- UPDATE DRIVER LOCATION -------------------
    public Driver updateLocation(Long driverId, Double latitude, Double longitude) {

        Driver driver = driverRepository.findById(driverId)
                .orElseThrow(() -> new RuntimeException("Driver not found"));

        driver.setLatitude(latitude);
        driver.setLongitude(longitude);

        Driver updated = driverRepository.save(driver);

        rideClient.sendLocation(driverId, latitude, longitude);

        return updated;
    }
}
    
    
    
//    public void setActiveRoute(List<List<Double>> route) {
//        this.activeRoute = route;
//        this.routePointer = 0;
//        this.routeCompleted = false;
//    }
//
//
//    // ------------------------------
//    //  SIMULATION LOGIC FIXED HERE
//    // ------------------------------
//    public void simulateMovement() {
//
//        if (currentDriverId == null) return;
//
//        if (activeRoute == null || routePointer >= activeRoute.size()) {
//
//            if (!routeCompleted) {
//                System.out.println("Route completed — stopping movement updates.");
//                routeCompleted = true;
//            }
//
//            stopMovement();   // STOP SCHEDULER CLEANLY
//            return;
//        }
//System.out.println("Route coordinates size-> "+activeRoute.size());
//        List<Double> point = activeRoute.get(routePointer);
//        double lon = point.get(0);
//        double lat = point.get(1);
//
//        routePointer++;
//
//        System.out.println("Driver Id: " + currentDriverId);
//
//        updateLocation(currentDriverId, lat, lon);
//    }
//
//
//    // ------------------------------
//    //  START + STOP MOVEMENT
//    // ------------------------------
//    public void startMovement(Long driverId) {
//
//        stopMovement(); // always stop old scheduler first
//
//        this.currentDriverId = driverId;
//
//        scheduler = Executors.newSingleThreadScheduledExecutor();
//
//        scheduler.scheduleAtFixedRate(() -> simulateMovement(),
//                0, 15, TimeUnit.SECONDS);
//    }
//
//
//    public void stopMovement() {
//        if (scheduler != null && !scheduler.isShutdown()) {
//            scheduler.shutdownNow();
//        }
//        scheduler = null;
//    }
//
//
//
//    // ------------------------------
//    // PREPARE ROUTE & START MOVING
//    // ------------------------------
//    public void prepareRouteAndStart(DriverRideRequest req) {
//
//        Long driverId = req.getDriverId();
//
//        List<List<Double>> route = fetchRoute(
//                req.getPickupLat(),
//                req.getPickupLon(),
//                req.getDropLat(),
//                req.getDropLon()
//        );
//
//        setActiveRoute(route);
//
//        startMovement(driverId);
//    }
//
//
//    // ------------------------------
//    // UPDATE LOCATION
//    // ------------------------------
//    public Driver updateLocation(Long driverId, Double latitude, Double longitude) {
//        Driver driver = driverRepository.findById(driverId)
//                .orElseThrow(() -> new RuntimeException("Driver not found"));
//
//        driver.setLatitude(latitude);
//        driver.setLongitude(longitude);
//        driverRepository.save(driver);
//
//        rideClient.sendLocation(driverId, latitude, longitude);
//
//        return driver;
//    }
//    
//    public List<List<Double>> fetchRoute(Double startLat, Double startLon, Double endLat, Double endLon) {
//        String start = startLon + "," + startLat;   // ORS uses lon,lat
//        String end = endLon + "," + endLat;
//
//        
//        ORSRouteResponse response = orsClient.getRoute(apiKey, start, end);
////        String raw = orsClient.getRoute(apiKey, start, end);
//        System.out.println("Raw response: "+response);
//        
//        if (response == null 
//                || response.getFeatures() == null 
//                || response.getFeatures().isEmpty()
//                || response.getFeatures().get(0).getGeometry() == null) 
//            {
//                throw new RuntimeException("Invalid ORS response: Missing features/geometry");
//            }
//
//            return response.getFeatures().get(0).getGeometry().getCoordinates();
////        return response.getRoutes().get(0).getGeometry().getCoordinates();
//    }
//}


//@Service
//public class DriverService {
//
//    @Autowired
//    private DriverRepository driverRepository;
//    
//    private List<List<Double>> activeRoute = new ArrayList<>();
//    private int routePointer = 0;
//    
//    @Autowired
//    private RideServiceClient rideClient;
//    
//    @Autowired
//    private OpenRouteServiceClient orsClient;
//    
//    private boolean routeCompleted = false;
//
//
//    @Value("${ors.api.key}")
//    private String apiKey;
//
//
 
//
//    public void setActiveRoute(List<List<Double>> route) {
//        this.activeRoute = route;
//        this.routePointer = 0; // reset movement
//    }
//    
 

//    
//    public void simulateMovement(Long driverId) {
//        if (activeRoute == null || routePointer >= activeRoute.size()) {
//        	if(!routeCompleted) {
//            System.out.println("Route completed — stopping movement updates.");
//            routeCompleted= true;}
//        	
//            return;
//        }
//
//        routeCompleted = false;
//        if (routePointer < activeRoute.size()) {
//
//            List<Double> point = activeRoute.get(routePointer);
//            double lon = point.get(0);
//            double lat = point.get(1);
//
//            routePointer++;
//System.out.println("Driver Id: "+driverId);
//            updateLocation(driverId, lat, lon);  // calling your existing method
//        }
//    }
//    
//    public void prepareRouteAndStart(DriverRideRequest req) {
//        Long driverId = req.getDriverId();
//        double pickupLat = req.getPickupLat();
//        double pickupLon = req.getPickupLon();
//        double dropLat = req.getDropLat();
//        double dropLon = req.getDropLon();
//System.out.println("Inside prepare Route start method");
//        // 1️⃣ Fetch route from ORS
//        List<List<Double>> route = fetchRoute(
//            pickupLat,
//            pickupLon,
//            dropLat,
//            dropLon
//        );
//        System.out.println("Fetch Route Worked");
//
//        // 2️⃣ Store in active route
//        setActiveRoute(route);
//
//        // 3️⃣ Start simulation immediately
//        simulateMovement(driverId);
//    }
//
//    public Driver updateLocation(Long driverId, Double latitude, Double longitude) {
//        Driver driver = driverRepository.findById(driverId)
//                .orElseThrow(() -> new RuntimeException("Driver not found"));
//        driver.setLatitude(latitude);
//        driver.setLongitude(longitude);
//        Driver updated = driverRepository.save(driver);
//
//        // NEW — Notify Ride Service
//        rideClient.sendLocation(driverId, latitude,longitude);
//
//        return updated;
//    }
//}

